; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=mina32 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=M32I

declare void @notdead(i8*)

; These tests must ensure the stack pointer is restored using the frame
; pointer

define void @simple_alloca(i32 %n) nounwind {
; M32I-LABEL: simple_alloca:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -4
; M32I-NEXT:    st r14, [sp, 0]
; M32I-NEXT:    addi r14, sp, 4
; M32I-NEXT:    addi r0, r0, 3
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    sub r0, sp, r0
; M32I-NEXT:    mov sp, r0
; M32I-NEXT:    movu r1, %hi(notdead)
; M32I-NEXT:    movl r1, %lo(notdead)
; M32I-NEXT:    rcall r1, 0
; M32I-NEXT:    addi sp, r14, -4
; M32I-NEXT:    ld r14, [sp, 0]
; M32I-NEXT:    addi sp, sp, 4
; M32I-NEXT:    ret
  %1 = alloca i8, i32 %n
  call void @notdead(i8* %1)
  ret void
}

declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8*)

define void @scoped_alloca(i32 %n) nounwind {
; M32I-LABEL: scoped_alloca:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -8
; M32I-NEXT:    st r14, [sp, 4]
; M32I-NEXT:    st r4, [sp, 0]
; M32I-NEXT:    addi r14, sp, 8
; M32I-NEXT:    mov r4, sp
; M32I-NEXT:    addi r0, r0, 3
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    sub r0, sp, r0
; M32I-NEXT:    mov sp, r0
; M32I-NEXT:    movu r1, %hi(notdead)
; M32I-NEXT:    movl r1, %lo(notdead)
; M32I-NEXT:    rcall r1, 0
; M32I-NEXT:    mov sp, r4
; M32I-NEXT:    addi sp, r14, -8
; M32I-NEXT:    ld r4, [sp, 0]
; M32I-NEXT:    ld r14, [sp, 4]
; M32I-NEXT:    addi sp, sp, 8
; M32I-NEXT:    ret
  %sp = call i8* @llvm.stacksave()
  %addr = alloca i8, i32 %n
  call void @notdead(i8* %addr)
  call void @llvm.stackrestore(i8* %sp)
  ret void
}
