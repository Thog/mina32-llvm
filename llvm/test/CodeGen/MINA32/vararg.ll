; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=mina32 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=M32I %s

declare void @llvm.va_start(i8*)
declare void @llvm.va_end(i8*)

declare void @notdead(i8*)

; Although frontends are recommended to not generate va_arg due to the lack of
; support for aggregate types, we test simple cases here to ensure they are
; lowered correctly

define i32 @va1(i8* %fmt, ...) nounwind {
; M32I-LABEL: va1:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -8
; M32I-NEXT:    st r14, [sp, 4]
; M32I-NEXT:    addi r14, sp, 8
; M32I-NEXT:    addi r0, r14, 8
; M32I-NEXT:    addi r0, r0, 4
; M32I-NEXT:    st r0, [r14, -8]
; M32I-NEXT:    ld r0, [r14, 8]
; M32I-NEXT:    ld r14, [sp, 4]
; M32I-NEXT:    addi sp, sp, 8
; M32I-NEXT:    ret
  %va = alloca i8*, align 4
  %1 = bitcast i8** %va to i8*
  call void @llvm.va_start(i8* %1)
  %argp.cur = load i8*, i8** %va, align 4
  %argp.next = getelementptr inbounds i8, i8* %argp.cur, i32 4
  store i8* %argp.next, i8** %va, align 4
  %2 = bitcast i8* %argp.cur to i32*
  %3 = load i32, i32* %2, align 4
  call void @llvm.va_end(i8* %1)
  ret i32 %3
}

define i32 @va1_va_arg(i8* %fmt, ...) nounwind {
; M32I-LABEL: va1_va_arg:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -8
; M32I-NEXT:    st r14, [sp, 4]
; M32I-NEXT:    addi r14, sp, 8
; M32I-NEXT:    addi r0, r14, 8
; M32I-NEXT:    addi r0, r0, 4
; M32I-NEXT:    st r0, [r14, -8]
; M32I-NEXT:    ld r0, [r14, 8]
; M32I-NEXT:    ld r14, [sp, 4]
; M32I-NEXT:    addi sp, sp, 8
; M32I-NEXT:    ret
  %va = alloca i8*, align 4
  %1 = bitcast i8** %va to i8*
  call void @llvm.va_start(i8* %1)
  %2 = va_arg i8** %va, i32
  call void @llvm.va_end(i8* %1)
  ret i32 %2
}

; Ensure the adjustment when restoring the stack pointer using the frame
; pointer is correct
define i32 @va1_va_arg_alloca(i8* %fmt, ...) nounwind {
; M32I-LABEL: va1_va_arg_alloca:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -12
; M32I-NEXT:    st r14, [sp, 8]
; M32I-NEXT:    st r4, [sp, 4]
; M32I-NEXT:    addi r14, sp, 12
; M32I-NEXT:    addi r0, r14, 8
; M32I-NEXT:    addi r0, r0, 4
; M32I-NEXT:    st r0, [r14, -12]
; M32I-NEXT:    ld r4, [r14, 8]
; M32I-NEXT:    addi r0, r4, 3
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    sub r0, sp, r0
; M32I-NEXT:    mov sp, r0
; M32I-NEXT:    movu r1, %hi(notdead)
; M32I-NEXT:    movl r1, %lo(notdead)
; M32I-NEXT:    rcall r1, 0
; M32I-NEXT:    mov r0, r4
; M32I-NEXT:    addi sp, r14, -12
; M32I-NEXT:    ld r4, [sp, 4]
; M32I-NEXT:    ld r14, [sp, 8]
; M32I-NEXT:    addi sp, sp, 12
; M32I-NEXT:    ret
  %va = alloca i8*, align 4
  %1 = bitcast i8** %va to i8*
  call void @llvm.va_start(i8* %1)
  %2 = va_arg i8** %va, i32
  %3 = alloca i8, i32 %2
  call void @notdead(i8* %3)
  call void @llvm.va_end(i8* %1)
  ret i32 %2
}

define void @va1_caller() nounwind {
; M32I-LABEL: va1_caller:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -20
; M32I-NEXT:    st r14, [sp, 16]
; M32I-NEXT:    addi r14, sp, 20
; M32I-NEXT:    movi r0, 2
; M32I-NEXT:    st r0, [sp, 12]
; M32I-NEXT:    movu r0, 16368
; M32I-NEXT:    st r0, [sp, 8]
; M32I-NEXT:    movi r0, 0
; M32I-NEXT:    st r0, [sp, 4]
; M32I-NEXT:    movu r0, %hi(va1)
; M32I-NEXT:    movl r0, %lo(va1)
; M32I-NEXT:    rcall r0, 0
; M32I-NEXT:    ld r14, [sp, 16]
; M32I-NEXT:    addi sp, sp, 20
; M32I-NEXT:    ret
; Pass a double, as a float would be promoted by a C/C++ frontend
  %1 = call i32 (i8*, ...) @va1(i8* undef, double 1.0, i32 2)
  ret void
}

declare void @llvm.va_copy(i8*, i8*)

define i32 @va2_va_copy(i32 %argno, ...) nounwind {
; M32I-LABEL: va2_va_copy:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -16
; M32I-NEXT:    st r14, [sp, 12]
; M32I-NEXT:    st r4, [sp, 8]
; M32I-NEXT:    addi r14, sp, 16
; M32I-NEXT:    addi r0, r14, 8
; M32I-NEXT:    addi r0, r0, 4
; M32I-NEXT:    st r0, [r14, -12]
; M32I-NEXT:    st r0, [r14, -16]
; M32I-NEXT:    ld r4, [r14, 8]
; M32I-NEXT:    movu r1, %hi(notdead)
; M32I-NEXT:    movl r1, %lo(notdead)
; M32I-NEXT:    rcall r1, 0
; M32I-NEXT:    ld r0, [r14, -12]
; M32I-NEXT:    addi r0, r0, 3
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    addi r1, r0, 4
; M32I-NEXT:    st r1, [r14, -12]
; M32I-NEXT:    ld r1, [r0, 0]
; M32I-NEXT:    addi r0, r0, 7
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    addi r2, r0, 4
; M32I-NEXT:    st r2, [r14, -12]
; M32I-NEXT:    ld r2, [r0, 0]
; M32I-NEXT:    addi r0, r0, 7
; M32I-NEXT:    andi r0, r0, -4
; M32I-NEXT:    addi r3, r0, 4
; M32I-NEXT:    st r3, [r14, -12]
; M32I-NEXT:    add r1, r1, r4
; M32I-NEXT:    add r1, r1, r2
; M32I-NEXT:    ld r0, [r0, 0]
; M32I-NEXT:    add r0, r1, r0
; M32I-NEXT:    ld r4, [sp, 8]
; M32I-NEXT:    ld r14, [sp, 12]
; M32I-NEXT:    addi sp, sp, 16
; M32I-NEXT:    ret
  %vargs = alloca i8*, align 4
  %wargs = alloca i8*, align 4
  %1 = bitcast i8** %vargs to i8*
  %2 = bitcast i8** %wargs to i8*
  call void @llvm.va_start(i8* %1)
  %3 = va_arg i8** %vargs, i32
  call void @llvm.va_copy(i8* %2, i8* %1)
  %4 = load i8*, i8** %wargs, align 4
  call void @notdead(i8* %4)
  %5 = va_arg i8** %vargs, i32
  %6 = va_arg i8** %vargs, i32
  %7 = va_arg i8** %vargs, i32
  call void @llvm.va_end(i8* %1)
  call void @llvm.va_end(i8* %2)
  %add1 = add i32 %5, %3
  %add2 = add i32 %add1, %6
  %add3 = add i32 %add2, %7
  ret i32 %add3
}

; A function with no fixed arguments is not valid C, but can be
; specified in LLVM IR. We must ensure the vararg save area is
; still set up correctly.

define i32 @va3_no_fixed_args(...) nounwind {
; M32I-LABEL: va3_no_fixed_args:
; M32I:       ; %bb.0:
; M32I-NEXT:    addi sp, sp, -8
; M32I-NEXT:    st r14, [sp, 4]
; M32I-NEXT:    addi r14, sp, 8
; M32I-NEXT:    addi r0, r14, 4
; M32I-NEXT:    addi r0, r0, 4
; M32I-NEXT:    st r0, [r14, -8]
; M32I-NEXT:    ld r0, [r14, 4]
; M32I-NEXT:    ld r14, [sp, 4]
; M32I-NEXT:    addi sp, sp, 8
; M32I-NEXT:    ret
  %va = alloca i8*, align 4
  %1 = bitcast i8** %va to i8*
  call void @llvm.va_start(i8* %1)
  %2 = va_arg i8** %va, i32
  call void @llvm.va_end(i8* %1)
  ret i32 %2
}
